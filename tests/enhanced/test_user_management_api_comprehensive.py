"""
Comprehensive API tests for: Create a new user
Generated by Enhanced Test Generator
Method: POST
Path: /api/v1/users
"""

import pytest
import httpx
import asyncio
from typing import Dict, Any, List, Optional
import os
from datetime import datetime, timedelta
import uuid
import random
import string

# Test configuration
BASE_URL = os.getenv('TEST_API_BASE_URL', 'http://localhost:8000')
AUTH_TOKEN = os.getenv('TEST_AUTH_TOKEN')
TIMEOUT = float(os.getenv('TEST_TIMEOUT', '30'))


def generate_valid_payload() -> Dict[str, Any]:
    """Generate valid test payload with realistic data"""
    return {
        "username": "test_username_",
        "email": "test_email@example.com",
        "password": "test_password_",
        "age": 69,
    }

def generate_invalid_payload(invalid_field: str = None) -> Dict[str, Any]:
    """Generate invalid test payload for negative testing"""
    
    if invalid_field == "username":
        # Remove required field
        payload = generate_valid_payload()
        del payload["username"]
        return payload
    if invalid_field == "username_too_short":
        payload = generate_valid_payload()
        payload["username"] = "x" * 2
        return payload
    if invalid_field == "username_too_long":
        payload = generate_valid_payload()
        payload["username"] = "x" * 21
        return payload
    if invalid_field == "email":
        # Remove required field
        payload = generate_valid_payload()
        del payload["email"]
        return payload
    if invalid_field == "password":
        # Remove required field
        payload = generate_valid_payload()
        del payload["password"]
        return payload
    if invalid_field == "password_too_short":
        payload = generate_valid_payload()
        payload["password"] = "x" * 7
        return payload
    
    # Default invalid payload
    return {"invalid_field": "invalid_value"}

def generate_boundary_payload(boundary_type: str) -> Dict[str, Any]:
    """Generate boundary condition test data"""
    payload = generate_valid_payload()
    
    
    if boundary_type == "username_min_length":
        payload["username"] = "x" * 3
    if boundary_type == "username_max_length":
        payload["username"] = "x" * 20
    if boundary_type == "password_min_length":
        payload["password"] = "x" * 8
    if boundary_type == "age_minimum":
        payload["age"] = 18
    if boundary_type == "age_maximum":
        payload["age"] = 120
    
    return payload


class UserManagementApiTests:
    """Comprehensive test suite for User Management API"""
    
    @pytest.fixture
    async def client(self):
        """HTTP client fixture with proper cleanup"""
        async with httpx.AsyncClient(
            base_url=BASE_URL,
            timeout=TIMEOUT,
            follow_redirects=True
        ) as client:
            yield client
    
    @pytest.fixture
    def auth_headers(self):
        """Authentication headers fixture"""
        if not AUTH_TOKEN:
            pytest.skip("AUTH_TOKEN environment variable not set")
        return {"Authorization": f"Bearer {AUTH_TOKEN}"}
    
    @pytest.fixture
    def invalid_auth_headers(self):
        """Invalid authentication headers for negative testing"""
        return {"Authorization": "Bearer invalid_token_12345"}


    @pytest.mark.asyncio
    async def test_user_management_api_success(self, client, auth_headers):
        """Test successful POST request to /api/v1/users"""
        payload = generate_valid_payload()
        
        response = await client.post("/api/v1/users", 
                                            json=payload, 
                                            headers=auth_headers)
        
        # Verify success response
        assert response.status_code in [200, 201], f"Expected [200, 201], got {response.status_code}"
        
        
        # Validate response structure
        if 'application/json' in response.headers.get('content-type', ''):
            response_data = response.json()
            assert isinstance(response_data, (dict, list)), "Response should be JSON object or array"
            
            # Add more specific validations based on response schema
            if isinstance(response_data, dict):
                # Common fields validation
                if 'id' in response_data:
                    assert isinstance(response_data['id'], (int, str)), "ID should be int or string"
                if 'created_at' in response_data:
                    assert response_data['created_at'], "created_at should not be empty"

    @pytest.mark.asyncio
    async def test_user_management_api_required_fields(self, client, auth_headers):
        """Test validation of required fields"""
        
        # Test missing username field
        response = await client.post("/api/v1/users", 
                                            json=generate_invalid_payload("username"), 
                                            headers=auth_headers)
        assert response.status_code == 400, f"Missing username should return 400"
        # Test missing email field
        response = await client.post("/api/v1/users", 
                                            json=generate_invalid_payload("email"), 
                                            headers=auth_headers)
        assert response.status_code == 400, f"Missing email should return 400"
        # Test missing password field
        response = await client.post("/api/v1/users", 
                                            json=generate_invalid_payload("password"), 
                                            headers=auth_headers)
        assert response.status_code == 400, f"Missing password should return 400"

    @pytest.mark.asyncio
    async def test_user_management_api_type_validation(self, client, auth_headers):
        """Test field type validation"""
        # Test with completely invalid JSON structure
        response = await client.post("/api/v1/users", 
                                            json={"invalid": "structure"}, 
                                            headers=auth_headers)
        assert response.status_code in [400, 422], "Invalid structure should return 400 or 422"
        
        # Test with malformed JSON
        response = await client.post("/api/v1/users", 
                                            content="{invalid json}", 
                                            headers=auth_headers)
        assert response.status_code == 400, "Malformed JSON should return 400"

    @pytest.mark.asyncio
    async def test_user_management_api_no_auth(self, client):
        """Test request without authentication"""
        payload = generate_valid_payload()
        
        response = await client.post("/api/v1/users", json=payload)
        assert response.status_code == 401, "Request without auth should return 401"
    
    @pytest.mark.asyncio
    async def test_user_management_api_invalid_auth(self, client, invalid_auth_headers):
        """Test request with invalid authentication"""
        payload = generate_valid_payload()
        
        response = await client.post("/api/v1/users", 
                                            json=payload, 
                                            headers=invalid_auth_headers)
        assert response.status_code == 401, "Request with invalid auth should return 401"

    # Performance and load testing
    @pytest.mark.performance
    @pytest.mark.asyncio
    async def test_user_management_api_response_time(self, client, auth_headers):
        """Test API response time under normal conditions"""
        payload = generate_valid_payload()
        
        start_time = datetime.now()
        response = await client.post("/api/v1/users", 
                                            json=payload, 
                                            headers=auth_headers)
        end_time = datetime.now()
        
        response_time = (end_time - start_time).total_seconds()
        
        # Assert response time is reasonable (< 2 seconds)
        assert response_time < 2.0, f"Response time {response_time}s exceeds 2s threshold"
        assert response.status_code < 500, "No server errors under normal load"
